[
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "vert"
        ],
        "name": "Object",
        "description": "containing the vertices."
      },
      {
        "type": "param",
        "types": [
          "g"
        ],
        "name": "The",
        "description": "graph that is to be drawn."
      }
    ],
    "description": {
      "full": "Function that adds the vertices found in the graph definition to the graph to be rendered.",
      "summary": "Function that adds the vertices found in the graph definition to the graph to be rendered.",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.addVertices = function (vert, g) {\n    var keys = Object.keys(vert);\n\n    var styleFromStyleArr = function(styleStr,arr){\n        var i;\n        // Create a compound style definition from the style definitions found for the node in the graph definition\n        for (i = 0; i < arr.length; i++) {\n            if (typeof arr[i] !== 'undefined') {\n                styleStr = styleStr + arr[i] + ';';\n            }\n        }\n\n        return styleStr;\n    };\n\n    // Iterate through each item in the vertice object (containing all the vertices found) in the graph definition\n    keys.forEach(function (id) {\n        var vertice = vert[id];\n        var verticeText;\n\n        var i;",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "addVertices",
      "string": "exports.addVertices()"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "types": [
          "string"
        ]
      }
    ],
    "description": {
      "full": "Variable for storing the extracted style for the vertice",
      "summary": "Variable for storing the extracted style for the vertice",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var style = '';\n        var classes = graph.getClasses();\n        // Check if class is defined for the node\n\n        if(vertice.classes.length >0){\n            for (i = 0; i < vertice.classes.length; i++) {\n                style = styleFromStyleArr(style,classes[vertice.classes[i]].styles);\n            }\n        }\n        else{\n            // Use default classes\n            style = styleFromStyleArr(style,classes.default.styles);\n        }\n\n\n        // Create a compound style definition from the style definitions found for the node in the graph definition\n        style = styleFromStyleArr(style, vertice.styles);\n\n        // Use vertice id as text in the box if no text is provided by the graph definition\n        if (typeof vertice.text === 'undefined') {\n            verticeText = vertice.id;\n        }\n        else {\n            verticeText = vertice.text;\n        }\n\n        var radious = 0;\n        var _shape = '';\n\n        // Set the shape based parameters\n        switch(vertice.type){\n            case 'round':\n                radious = 5;\n                _shape = 'rect';\n                break;\n            case 'square':\n                _shape = 'rect';\n                break;\n            case 'diamond':\n                _shape = 'question';\n                break;\n            case 'odd':\n                _shape = 'rect_left_inv_arrow';\n                break;\n            case 'circle':\n                _shape = 'circle';\n                break;\n            default:\n                _shape = 'rect';\n        }\n        // Add the node\n        g.setNode(vertice.id, {labelType: \"html\",shape:_shape, label: verticeText, rx: radious, ry: radious, style: style, id:vertice.id});\n    });\n};",
    "ctx": {
      "type": "declaration",
      "name": "style",
      "value": "''",
      "string": "style"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "edges",
        "description": "The edges to add to the graph"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "g",
        "description": "The graph object"
      }
    ],
    "description": {
      "full": "Add edges to graph based on parsed graph defninition",
      "summary": "Add edges to graph based on parsed graph defninition",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.addEdges = function (edges, g) {\n    var cnt=0;\n    var aHead;\n    edges.forEach(function (edge) {\n        cnt++;\n\n        // Set link type for rendering\n        if(edge.type === 'arrow_open'){\n            aHead = 'none';\n        }\n        else{\n            aHead = 'normal';\n        }\n\n        var style = '';\n        if(typeof edge.style !== 'undefined'){\n            edge.style.forEach(function(s){\n                style = style + s +';';\n            });\n        }\n\n        // Add the edge to the graph\n        if (typeof edge.text === 'undefined') {\n            if(typeof edge.style === 'undefined'){\n                g.setEdge(edge.start, edge.end,{ style: \"stroke: #333; stroke-width: 1.5px;fill:none\", arrowheadStyle: \"fill: #333\", arrowhead: aHead},cnt);\n            }else{\n                g.setEdge(edge.start, edge.end, {\n                    style: style, arrowheadStyle: \"fill: #333\", arrowhead: aHead\n                },cnt);\n            }\n        }\n        // Edge with text\n        else {\n\n            if(typeof edge.style === 'undefined'){\n                g.setEdge(edge.start, edge.end,{labelType: \"html\",style: \"stroke: #333; stroke-width: 1.5px;fill:none\", labelpos:'c', label: '<span style=\"background:#e8e8e8\">'+edge.text+'</span>', arrowheadStyle: \"fill: #333\", arrowhead: aHead},cnt);\n            }else{\n                g.setEdge(edge.start, edge.end, {\n                    labelType: \"html\",style: style, arrowheadStyle: \"fill: #333\", label: edge.text, arrowhead: aHead\n                },cnt);\n            }\n        }\n    });\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "addEdges",
      "string": "exports.addEdges()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "text"
        ],
        "name": "",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "id"
        ],
        "name": "",
        "description": ""
      }
    ],
    "description": {
      "full": "Draws a flowchart in the tag with id: id based on the graph definition in text.",
      "summary": "Draws a flowchart in the tag with id: id based on the graph definition in text.",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var draw = function (text, id,isDot) {\n    var parser;\n    graph.clear();\n    if(isDot){\n        parser = dot.parser;\n\n    }else{\n        parser = flow.parser;\n    }\n    parser.yy = graph;\n\n    // Parse the graph definition\n    parser.parse(text);\n\n    // Fetch the default direction, use TD if none was found\n    var dir;\n    dir = graph.getDirection();\n    if(typeof dir === 'undefined'){\n        dir='TD';\n    }\n\n    // Create the input mermaid.graph\n    var g = new dagreD3.graphlib.Graph({multigraph:true})\n        .setGraph({\n            rankdir: dir,\n            marginx: 20,\n            marginy: 20\n\n        })\n        .setDefaultEdgeLabel(function () {\n            return {};\n        });\n\n    // Fetch the verices/nodes and edges/links from the parsed graph definition\n    var vert = graph.getVertices();\n    var edges = graph.getEdges();\n    var classes = graph.getClasses();\n\n    if(typeof classes.default === 'undefined'){\n        classes.default = {id:'default'};\n        classes.default.styles = ['fill:#eaeaea','stroke:#666','stroke-width:1.5px'];\n    }\n    exports.addVertices(vert, g);\n    exports.addEdges(edges, g);\n\n    // Create the renderer\n    var render = new dagreD3.render();\n\n    // Add custom shape for rhombus type of boc (decision)\n    render.shapes().question = function (parent, bbox, node) {\n        var w = bbox.width,\n            h = bbox.height,\n            s = (w + h) * 0.8,\n            points = [\n                {x: s / 2, y: 0},\n                {x: s, y: -s / 2},\n                {x: s / 2, y: -s},\n                {x: 0, y: -s / 2}\n            ];\n        shapeSvg = parent.insert(\"polygon\", \":first-child\")\n            .attr(\"points\", points.map(function (d) {\n                return d.x + \",\" + d.y;\n            }).join(\" \"))\n            .style(\"fill\", \"#fff\")\n            .style(\"stroke\", \"#333\")\n            .attr(\"rx\", 5)\n            .attr(\"ry\", 5)\n            .attr(\"transform\", \"translate(\" + (-s / 2) + \",\" + (s * 2 / 4) + \")\");\n        node.intersect = function (point) {\n            return dagreD3.intersect.polygon(node, points, point);\n        };\n        return shapeSvg;\n    };\n\n    // Add custom shape for box with inverted arrow on left side\n    render.shapes().rect_left_inv_arrow = function (parent, bbox, node) {\n        var w = bbox.width,\n            h = bbox.height,\n            points = [\n                {x: -h/2, y: 0},\n                {x: w, y: 0},\n                {x: w, y: -h},\n                {x: -h/2, y: -h},\n                {x: 0, y: -h/2},\n            ];\n        shapeSvg = parent.insert(\"polygon\", \":first-child\")\n            .attr(\"points\", points.map(function (d) {\n                return d.x + \",\" + d.y;\n            }).join(\" \"))\n            .style(\"fill\", \"#fff\")\n            .style(\"stroke\", \"#333\")\n            .attr(\"transform\", \"translate(\" + (-w / 2) + \",\" + (h * 2 / 4) + \")\");\n        node.intersect = function (point) {\n            return dagreD3.intersect.polygon(node, points, point);\n        };\n        return shapeSvg;\n    };\n\n    // Add our custom arrow - an empty arrowhead\n    render.arrows().none = function normal(parent, id, edge, type) {\n      var marker = parent.append(\"marker\")\n        .attr(\"id\", id)\n        .attr(\"viewBox\", \"0 0 10 10\")\n        .attr(\"refX\", 9)\n        .attr(\"refY\", 5)\n        .attr(\"markerUnits\", \"strokeWidth\")\n        .attr(\"markerWidth\", 8)\n        .attr(\"markerHeight\", 6)\n        .attr(\"orient\", \"auto\");\n\n      var path = marker.append(\"path\")\n        .attr(\"d\", \"M 0 0 L 0 0 L 0 0 z\");\n      dagreD3.util.applyStyle(path, edge[type + \"Style\"]);\n    };\n\n    // Set up an SVG group so that we can translate the final graph.\n    var svg = d3.select(\"#\" + id);\n    svgGroup = d3.select(\"#\" + id + \" g\");\n\n    // Run the renderer. This is what draws the final graph.\n    render(d3.select(\"#\" + id + \" g\"), g);\n\n    // Center the graph\n    var xCenterOffset = (svg.attr(\"width\") - g.graph().width) / 2;\n    //svgGroup.attr(\"transform\", \"translate(\" + xCenterOffset + \", 20)\");\n    svg.attr(\"height\", g.graph().height );\n    svg.attr(\"width\", g.graph().width );\n};",
    "ctx": {
      "type": "function",
      "name": "draw",
      "string": "draw()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Function that goes through the document to find the chart definitions in there and render them.\n\nThe function tags the processed attributes with the attribute data-processed and ignores found elements with the\nattribute already set. This way the init function can be triggered several times.\n\n```\ngraph LR;\n a(Find elements)-->b{Processed};\n b-->|Yes|c(Leave element);\n c-->|No |d(Transform);\n```",
      "summary": "Function that goes through the document to find the chart definitions in there and render them.",
      "body": "The function tags the processed attributes with the attribute data-processed and ignores found elements with the\nattribute already set. This way the init function can be triggered several times.\n\n```\ngraph LR;\n a(Find elements)-->b{Processed};\n b-->|Yes|c(Leave element);\n c-->|No |d(Transform);\n```"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var init = function () {\n    var arr = document.querySelectorAll('.mermaid');\n\n    var cnt = 0;\n    for (i = 0; i < arr.length; i++) {\n        var element = arr[i];\n\n        // Check if previously processed\n        if(!element.getAttribute(\"data-processed\")) {\n            element.setAttribute(\"data-processed\", true);\n        } else continue;\n\n        var id;\n\n        id = 'mermaidChart' + cnt;\n        cnt++;\n\n        var txt = element.innerHTML;\n        txt = txt.replace(/>/g,'&gt;');\n        txt = txt.replace(/</g,'&lt;');\n        txt = he.decode(txt).trim();\n\n        element.innerHTML = '<svg id=\"' + id + '\">' +\n        '<g />' +\n        '</svg>';\n\n        var graphType = utils.detectType(txt);\n\n        switch(graphType){\n            case 'graph':\n                draw(txt, id,false);\n                graph.bindFunctions();\n            break;\n            case 'dotGraph':\n                draw(txt, id,true);\n                break;\n            case 'sequenceDiagram':\n                seq.draw(txt,id);\n                break;\n        }\n\n    }\n\n};\n\nexports.tester = function(){};",
    "ctx": {
      "type": "function",
      "name": "init",
      "string": "init()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "{string} A string containing the version info"
      }
    ],
    "description": {
      "full": "Function returning version information",
      "summary": "Function returning version information",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.version = function(){\n    return require('../package.json').version;\n};\n\nvar equals = function (val, variable){\n    if(typeof variable === 'undefined'){\n        return false;\n    }\n    else{\n        return (val === variable);\n    }\n};\nif(typeof document !== 'undefined'){",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "version",
      "string": "exports.version()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Wait for coument loaded before starting the execution",
      "summary": "Wait for coument loaded before starting the execution",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "document.addEventListener('DOMContentLoaded', function(){\n        // Check presence of config object\n        if(typeof mermaid_config !== 'undefined'){\n            // Check if property startOnLoad is set\n            if(equals(true,mermaid_config.startOnLoad)){\n                init();\n            }\n        }\n        else{\n            // No config found, do autostart in this simple case\n            init();\n        }\n    }, false);\n\n}\n\n\nglobal.mermaid = {\n    init:function(){\n        init();\n    },\n    version:function(){\n        return exports.version();\n    },\n    getParser:function(){\n        return flow.parser;\n    }\n};"
  }
]